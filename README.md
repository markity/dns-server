# dns-server

一个dns-server, 用来学习计算机网络, 写一个能通过配置文件配置的dns服务器。

这个repo只是用来做一个简单的名称-ip解析服务(类型A), 也不涉及真实网络环境的递归查询。

# 实验-看报文

请求方和响应方都发udp报文, dns-server跑在53端口, 因此我们可以自己写个dns server, 然后添加到`/etc/resolv.conf`里面看看报文。

下面是代码:

```go
package main

import (
	"fmt"
	"net"
)

func main() {
	c, err := net.ListenUDP("udp4", &net.UDPAddr{IP: net.IPv4(127, 0, 0, 1), Port: 53})
	if err != nil {
		panic(err)
	}

	bs := make([]byte, 3000)
	for {
		n, err := c.Read(bs)
		if err != nil {
			panic(err)
		}

		fmt.Println(bs[:n])
	}
}

```

加入到`/etc/resolv.conf`后`ping baidu.com`得到一些输出:

```tex
[145 185 1 0 0 1 0 0 0 0 0 0 5 98 97 105 100 117 3 99 111 109 0 0 1 0 1]
[93 189 1 0 0 1 0 0 0 0 0 0 5 98 97 105 100 117 3 99 111 109 0 0 28 0 1]
[97 173 1 0 0 1 0 0 0 0 0 0 12 116 112 115 116 101 108 101 109 101 116 114 121 7 116 101 110 99 101 110 116 3 99 111 109 0 0 1 0 1]
[147 213 1 0 0 1 0 0 0 0 0 0 12 116 112 115 116 101 108 101 109 101 116 114 121 7 116 101 110 99 101 110 116 3 99 111 109 0 0 28 0 1]
[211 231 1 0 0 1 0 0 0 0 0 0 5 98 97 105 100 117 3 99 111 109 0 0 1 0 1]
[108 229 1 0 0 1 0 0 0 0 0 0 5 98 97 105 100 117 3 99 111 109 0 0 28 0 1]
[10 115 1 0 0 1 0 0 0 0 0 0 2 108 112 4 111 112 101 110 6 119 101 105 120 105 110 2 113 113 3 99 111 109 0 0 1 0 1]
[13 127 1 0 0 1 0 0 0 0 0 0 2 108 112 4 111 112 101 110 6 119 101 105 120 105 110 2 113 113 3 99 111 109 0 0 28 0 1]
[104 217 1 0 0 1 0 0 0 0 0 0 2 54 54 2 54 56 3 50 52 50 3 49 49 48 7 105 110 45 97 100 100 114 4 97 114 112 97 0 0 12 0 1]
[228 29 1 0 0 1 0 0 0 0 0 0 2 54 54 2 54 56 3 50 52 50 3 49 49 48 7 105 110 45 97 100 100 114 4 97 114 112 97 0 0 12 0 1]
[94 185 1 0 0 1 0 0 0 0 0 0 2 54 54 2 54 56 3 50 52 50 3 49 49 48 7 105 110 45 97 100 100 114 4 97 114 112 97 0 0 12 0 1]
[23 176 1 0 0 1 0 0 0 0 0 0 2 54 54 2 54 56 3 50 52 50 3 49 49 48 7 105 110 45 97 100 100 114 4 97 114 112 97 0 0 12 0 1]
[166 149 1 0 0 1 0 0 0 0 0 0 5 98 97 105 100 117 3 99 111 109 0 0 1 0 1]
[136 150 1 0 0 1 0 0 0 0 0 0 5 98 97 105 100 117 3 99 111 109 0 0 28 0 1]
[161 95 1 0 0 1 0 0 0 0 0 0 3 111 116 104 3 115 116 114 6 98 101 97 99 111 110 2 113 113 3 99 111 109 0 0 1 0 1]
[177 97 1 0 0 1 0 0 0 0 0 0 3 111 116 104 3 115 116 114 6 98 101 97 99 111 110 2 113 113 3 99 111 109 0 0 28 0 1]
[1 102 1 0 0 1 0 0 0 0 0 0 6 111 116 104 101 118 101 6 98 101 97 99 111 110 2 113 113 3 99 111 109 0 0 1 0 1]
[27 105 1 0 0 1 0 0 0 0 0 0 6 111 116 104 101 118 101 6 98 101 97 99 111 110 2 113 113 3 99 111 109 0 0 28 0 1]
[62 25 1 0 0 1 0 0 0 0 0 0 12 116 112 115 116 101 108 101 109 101 116 114 121 7 116 101 110 99 101 110 116 3 99 111 109 0 0 1 0 1]
[213 37 1 0 0 1 0 0 0 0 0 0 12 116 112 115 116 101 108 101 109 101 116 114 121 7 116 101 110 99 101 110 116 3 99 111 109 0 0 28 0 1]
[203 29 1 0 0 1 0 0 0 0 0 0 4 109 55 48 49 5 109 117 115 105 99 3 49 50 54 3 110 101 116 0 0 1 0 1]
[57 30 1 0 0 1 0 0 0 0 0 0 4 109 55 48 49 5 109 117 115 105 99 3 49 50 54 3 110 101 116 0 0 28 0 1]
[75 122 1 0 0 1 0 0 0 0 0 0 4 109 55 48 49 5 109 117 115 105 99 3 49 50 54 3 110 101 116 0 0 1 0 1]
[162 121 1 0 0 1 0 0 0 0 0 0 4 109 55 48 49 5 109 117 115 105 99 3 49 50 54 3 110 101 116 0 0 28 0 1]
[223 234 1 0 0 1 0 0 0 0 0 0 2 112 49 5 109 117 115 105 99 3 49 50 54 3 110 101 116 0 0 1 0 1]
[219 16 1 0 0 1 0 0 0 0 0 0 2 112 49 5 109 117 115 105 99 3 49 50 54 3 110 101 116 0 0 28 0 1]
[246 31 1 0 0 1 0 0 0 0 0 0 2 112 50 5 109 117 115 105 99 3 49 50 54 3 110 101 116 0 0 1 0 1]
[60 18 1 0 0 1 0 0 0 0 0 0 2 112 50 5 109 117 115 105 99 3 49 50 54 3 110 101 116 0 0 28 0 1]
[233 47 1 0 0 1 0 0 0 0 0 0 2 112 50 5 109 117 115 105 99 3 49 50 54 3 110 101 116 0 0 1 0 1]
[183 32 1 0 0 1 0 0 0 0 0 0 2 112 50 5 109 117 115 105 99 3 49 50 54 3 110 101 116 0 0 28 0 1]
[170 254 1 0 0 1 0 0 0 0 0 0 2 112 50 5 109 117 115 105 99 3 49 50 54 3 110 101 116 0 0 1 0 1]
[28 229 1 0 0 1 0 0 0 0 0 0 2 112 50 5 109 117 115 105 99 3 49 50 54 3 110 101 116 0 0 28 0 1]
[217 245 1 0 0 1 0 0 0 0 0 0 2 112 49 5 109 117 115 105 99 3 49 50 54 3 110 101 116 0 0 1 0 1]
[174 242 1 0 0 1 0 0 0 0 0 0 2 112 49 5 109 117 115 105 99 3 49 50 54 3 110 101 116 0 0 28 0 1]
[116 204 1 0 0 1 0 0 0 0 0 0 4 112 105 110 103 9 97 114 99 104 108 105 110 117 120 3 111 114 103 0 0 1 0 1]
[34 199 1 0 0 1 0 0 0 0 0 0 4 112 105 110 103 9 97 114 99 104 108 105 110 117 120 3 111 114 103 0 0 28 0 1]
```

# 报文解析

请求方和响应方都发udp报文, 下面来解析报文的结构, 它们共有的结构如下, 下面是报文首部:

### 首部

- [0, 1] : 前两字节是事务ID, 相当于客户端请求的标识, 想想客户端可能同时向一个dns-server发两个解析请求, 客户端就得生成两个不同的标识, 服务端原样返回, 这样客户端就能区分它们了
- [2, 3] : 第三个字节和第四个字节是标志位, 各有各自的作用

| 位                            | 说明                                                         |
| ----------------------------- | ------------------------------------------------------------ |
| QR(1bit)                      | 查询(Query)/响应(Response)标志，0为查询，1为响应             |
| opcode(4bit)                  | 表示操作码，0 表示标准查询；1 表示反向查询；2 表示服务器状态请求 |
| AA(Authoritative)(1bit)       | 对于请求, 这个为0即可<br />表示是否是权威DNS服务器发来的应答，该字段在响应报文中有效。值为 1 时，表示名称服务器是权威服务器；值为 0 时，表示不是权威服务器。那么什么是权威服务器呢, 我们知道一台dns服务器不能存世界上所有的域名, 因此dns解析是分布式的, 我们可以访问根域名服务器, 拿到可能存有目标域名的子dns服务器ip, 然后再访问这个子dns服务器...最终我们能拿到ip。那么最后能拿到ip的那个服务器就是权威DNS服务器。也就是说权威DNS服务器是解析一个域名的最后一站 |
| TC(Truncated)(1bit)           | 表示是否被截断。值为 1 时，表示响应已超过 512 字节并已被截断，只返回前 512 个字节 |
| RD(Recursion Desired)(1bit)   | 对于响应, 这个为0即可<br />是否期望递归。0表示迭代查询，1表示递归查询<br />那么到底什么是递归查询呢? 这里有解答https://serverfault.com/questions/182455/who-actually-recurses-in-a-recursive-dns-lookup, 我们的server不支持递归查询 |
| RA(Recursion Available)(1bit) | 对请求, 这个字段没有意义, 为1即可, 为什么为1呢? 这个我也不知道, 我抓包发现请求的RA为1<br />是否支持递归。该字段只出现在响应报文中。当值为 1 时，表示服务器支持递归查询 |
| ZERO(3bit)                    | 表示保留字段, 必须为0                                        |
| rcode(Reply code)(4bit)       | 返回码字段，表示响应的差错状态, 请求就把它写为0吧。<br />当值为 0 时，表示没有错误；<br />当值为 1 时，表示报文格式错误（Format error），服务器不能理解请求的报文；<br />当值为 2 时，表示域名服务器失败（Server failure），因为服务器的原因导致没办法处理这个请求；<br />当值为 3 时，表示名字错误（Name Error），只有对授权域名解析服务器有意义，指出解析的域名不存在；<br />当值为 4 时，表示查询类型不支持（Not Implemented），即域名服务器不支持查询类型；<br />当值为 5 时，表示拒绝（Refused），一般是服务器由于设置的策略拒绝给出应答，如服务器不希望对某些请求者给出应答 |

- [4,5] : 问题数, 通常只有一个问题, 也就是说一次udp请求一般只问一个问题, 但是服务器要更符合标准, 应该支持多个问题
- [6,7] :  回答数
- [8,9] : 权威名称服务器数
- [10,11] : 额外资源数

### 负载部分

上面的首部的12字节是请求和响应都有的, 剩下的部分是重要信息, 且大小不是固定的。分为以下四个区域:

- 问题区域, 注意请求方和响应方都会有这个区域的, 响应方通常原样拷贝请求方的这个区域

  从标准来看是支持多个问题的, 问题是这样的一个结构

  - 首先是Name(字节大小数不确定, 需要动态解析), 比如查询A记录, 需要的就是域名, 例如www.baidu.com没, 由于Name的长度是不确定的, 它是这样的一个结构

    ```
    3 w w w 5 b a i d u 3 c o m 0
    
    - 第一个3代表后面有三个字符分一个级别
    - 第二个5代表第二个级别有5个字符
    - 第三个3代表第三个级别有3个字符
    - 0代表结束
    
    通过这样的表示, 就能把www.baidu.com表示出来了
    ```

  - 然后是Type(两个字节), 1表示A类, 即拿为域名对应的ipv4地址, 28为IPV6地址, 15为MX地址, 还有很多其它的类型不提了, 我的dns-server关注的是ipv4地址, 不支持其它Type。此外还有一些type已经过时了, 因为dns协议是很古老的协议。一个特殊的type是255, 它代表请求对这个Name的所有记录类型

  - 查询类(两个字节), 1为互联网, 我不清楚除了互联网还有什么

  > 这样要注意的是, 无论响应的rcode是多少, 回答都应该原样返回请求的问题, 比如dns server返回的rcode=3, 来指示这个域名不存在, 响应的问题数依然是1。只是回答数, 权威名称服务器数和额外资源数为0罢了

- 回答区域, 只有响应才有, 下面是回答区域的结构

  - 包括域名(不定长), 规则之前已经提到了: 例如`3 www 5 baidu 3 com 0`

  - Type(2字节), 我们关注的是1代表A类, 即ipv4

  - 查询类(2字节), 为1, 互联网, 我不关心除了互联网还有啥网

  - 生存周期(4字节), 代表一个秒数表示有效日期, 一般选择是两天

  - 资源数据的长度(2字节), 记录后面紧跟的资源数据的长度

  - 资源数据, 长度根据`资源数据的长度`这个字段指示, 比如ipv4占的长度就是4(四个字节表示一个ipv4)

    > 我们要注意, 同一个域名的一种类型的记录可能有多条, 比如baidu.com, 我们能查到两条A记录, 我们的服务器要支持一个域名返回多个ipv4地址
    > 此外的细节是, 如果dns服务器确定no such host, 服务器的AA位为0

- 权威名称服务器区域, 只有响应才有, 其实对我们的dns-server不用关注, 因为我们不支持递归查询

  这个区域包含了可能含有该域名的所有dns server的权威名称服务器的域名, 我们不用关心

- 额外区域, 只有响应才有: 请求方允许递归查询且服务器支持递归查询的时候, 会把服务器列表放这里

  这个区域包含了可能含有该域名的所有dns server的权威名称服务器的ip, 我们不用关心

  > 要了解权威服务器相关的字段, 可以看看http://c.biancheng.net/view/6457.html。这里有抓包结果, 我们的实现不关心权威名称服务器区域和额外区域

### 实现的细节

- 如果/etc/resolv.conf里配置的nameserver在无法使用的时候应该立刻剔除, 否则就会出现很多解析失败的情况, 解析会非常龟速(因为多次解析失败后才有机会使用第二条nameserver)。

  来解释下为什么是龟速而不是失败呢, dns server不可用的时候, rcode可以是2(代表服务器现在由于本身问题不可用)。这时操作系统查询dns的接口就会尝试其他配置的nameserver, 可见这里进行了多次查询, 就很龟速了。

  此外, 如果dns server直接不响应, 操作系统的查询dns的接口也会等待很久后再尝试其它配置的nameserver。

- 默认情况下我的linux能接受递归查询, 也就是把请求的RD设置为1。且我使用的dns server支持迭代查询, 此时响应必然是要么有这个host, 给我相应的回答, 要么就是no such host。

  但是在dns server不支持递归查询的时候, 且dns server不是此域名的权威服务器, 那么rcode就为0, 且返回一些可能的权威服务器(在权威服务器区域)和额外信息(包含权威服务器的ip)。然后让我们自己迭代查询。

- 在进行迭代查询的时候, 如果此dns server不是权威名称服务器, rcode为0, 在权威服务器和额外信息里面就有权威服务器的域名和ip了。我们需要自己迭代所有的服务器进行查询, 直到查到, 如果对所有服务器迭代到最底层均未查到, 那么就证明no such host。

- 客户端迭代查询是低效的, 我们dhcp配置到的dns server有的是缓存服务器, 能很快地查到。因此打开RD位对上网更高效。

# 实验, 打印请求的所有信息

刚才我们打印出了报文的信息, 现在我们来实践一下, 看看根据协议, dns请求究竟是怎样的, 下面是代码:

```go
package main

import (
	"encoding/binary"
	"fmt"
	"net"
)

func main() {
	c, err := net.ListenUDP("udp4", &net.UDPAddr{IP: net.IPv4(127, 0, 0, 1), Port: 53})
	if err != nil {
		panic(err)
	}

	bs := make([]byte, 3000)
	for {
		n, err := c.Read(bs)
		if err != nil {
			panic(err)
		}

		// 1 1 1 1 1 1 1 1 1 1 1 1
		// 1 1 1
		//   1 1 1
		//     1 1 1
		//       1 1 1
		//         1 1 1
		//           1 1 1
		//             1 1 1
		//               1 1 1
		//                 1 1 1
		//                   1 1 1
		pack := bs[:n]
		tx := binary.BigEndian.Uint16(pack[0:2])
		flag := binary.BigEndian.Uint16(pack[2:4])
		que := binary.BigEndian.Uint16(pack[4:6])
		ans := binary.BigEndian.Uint16(pack[6:8])
		authNum := binary.BigEndian.Uint16(pack[8:10])
		addNum := binary.BigEndian.Uint16(pack[10:12])

		fmt.Printf("TransID: %v\n", tx)
		fmt.Printf("opcode:\n")
		fmt.Printf("  QR: %v\n", flag&1)
		fmt.Printf("  opcode: %v\n", flag&(0b1111<<1))
		fmt.Printf("  AA: %v\n", flag&(1<<5))
		fmt.Printf("  TC: %v\n", flag&(1<<6))
		fmt.Printf("  RD: %v\n", flag&(1<<7))
		fmt.Printf("  RA: %v\n", flag&(1<<7))
		fmt.Printf("  rcode: %v\n", flag&(0b111<<9))
		fmt.Printf("questions: %v\n", que)
		fmt.Printf("answers: %v\n", ans)
		fmt.Printf("auth num: %v\n", authNum)
		fmt.Printf("add num: %v\n", addNum)

	}
}
```

下面是一些输出:

```tex
TransID: 24666
opcode:
  QR: 0
  opcode: 0
  AA: 0
  TC: 0
  RD: 0
  RA: 0
  rcode: 0
questions: 1
answers: 0
auth num: 0
add num: 0
TransID: 21085
opcode:
  QR: 0
  opcode: 0
  AA: 0
  TC: 0
  RD: 0
  RA: 0
  rcode: 0
questions: 1
answers: 0
auth num: 0
add num: 0
```
